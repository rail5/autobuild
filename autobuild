#!/usr/bin/env bash

# autobuild
# Copyright (C) 2024 rail5
# Free software (GNU Affero GPL v3)

if [ "$(whoami)" == "root" ]; then
	echo "Warning: autobuild should NOT be run as root."
	sleep 1
fi

tempdirectory=$(dirname "$(mktemp -u)")
initial_directory=$(mktemp --tmpdir -d autobuild.XXXXXXXXXXXX)
local_storage_directory="$HOME/.local/share/autobuild"
build_farm_directory="$local_storage_directory/build-farm"
package_directory="$local_storage_directory/packages"
autobuild_directory="/usr/share/autobuild"
pkgs_build_base_directory="builds/$(date +%Y-%h-%d-%H%M%S)"

amd64_vm_is_configured=false
i386_vm_is_configured=false
arm64_vm_is_configured=false

if [[ -f "$local_storage_directory/build-farm/debian-stable-amd64/image.qcow" ]]; then
	amd64_vm_is_configured=true
fi

if [[ -f "$local_storage_directory/build-farm/debian-stable-i386/image.qcow" ]]; then
	i386_vm_is_configured=true
fi

if [[ -f "$local_storage_directory/build-farm/debian-stable-arm64/image.qcow" ]]; then
	arm64_vm_is_configured=true
fi

base_release_directory=""


# Declare the lists of packages we'll be building
# These arrays will be populated with the packages selected by the user
packages_to_build=()
amd64_builds=()
i386_builds=()
arm64_builds=()


# How will we distribute the built packages?
# These arrays will be populated etc etc
packages_to_publish_to_repo=()
release_pages_to_make=()

# Where are we saving the built package files?
# Current working directory by default. User can change with -o
output_directory="$(pwd)"

## SSH connection into the build-farm VMs
SSHPASSWORD="debianpassword"
SSHUSER="debian"
SSHPORT="22222"


# Load configuration

CONFIG_FILE="$local_storage_directory/config.toml"

BUILDFARM_SCRIPTS_FILE="$autobuild_directory/build-farm/scripts/scripts.sh"

if [ ! -d "$local_storage_directory" ]; then
	mkdir "$local_storage_directory"
	cp -r "/usr/share/autobuild/"* "$local_storage_directory/"
fi

# Copy the build-farm scripts to $local_storage_directory in case an upgrade took place
cp -r "/usr/share/autobuild/build-farm/"* "$local_storage_directory/build-farm/"

if [ ! -f "$CONFIG_FILE" ]; then
	cp "$autobuild_directory/config.toml" "$CONFIG_FILE"
fi

mkdir -p "$package_directory"


##################################################
# Parse config file
#
config_json=$(toml2json "$CONFIG_FILE")

## Package settings
number_of_packages=$(jq -r ".packages.package_urls | length" <<<"$config_json")
declare -A packages
packages=()
for ((i = 0; i < number_of_packages; i++)); do
	package_url=$(jq -r ".packages.package_urls[$i]" <<<"$config_json")
	package_name=$(basename "$package_url")
	package_name="${package_name/.git/""}"

	packages+=(["$package_name"]="$package_url")
done

## Distribution settings
OWNER=$(jq -r ".distribution.repo_owner" <<<"$config_json")

### Check for Github access token
### If the user provided a path to a GPG-encrypted file, prefer that
ACCESS_TOKEN=$(jq -r ".distribution.access_token" <<<"$config_json")
ACCESS_TOKEN_FILE=$(jq -r ".distribution.access_token_gpg_encrypted_file" <<<"$config_json")

if [[ "$ACCESS_TOKEN_FILE" != "null" ]]; then
	ACCESS_TOKEN=$(gpg -d "$ACCESS_TOKEN_FILE" 2>/dev/null)
fi

git_debianrepo=$(jq -r ".distribution.git_debian_repo" <<<"$config_json")
##################################################


# shellcheck source=./build-farm/scripts/scripts.sh
. "$BUILDFARM_SCRIPTS_FILE"


# BEFORE WE START:
# Let's verify that ALL of the subdirectories under $package_directory correspond to key in the "packages" associative array
## If we find a subdirectory under $package_directory which DOES NOT correspond to a key in "packages",
## We should remove it.
# This way, we avoid taking up unnecessary space on the user's machine
## In the event that the user decides to remove a package from their autobuild config.
OLDIFS="$IFS"
IFS="
"
for subdir in "$package_directory/"*; do
	subdir="$(basename "$subdir")"
	if [[ "${packages[$subdir]+true}" ]]; then
		# Package exists in our packages array
		continue
	else
		# Package DOES NOT exist in our packages array
		rm -rf "${package_directory:?}/${subdir:?}"
	fi
done
IFS="$OLDIFS"

# Now carry on


function setup_build_environment() {
	mkdir -p "$initial_directory/$pkgs_build_base_directory"

	mkdir "$initial_directory/$pkgs_build_base_directory/srconly"
	mkdir "$initial_directory/$pkgs_build_base_directory/deb"
	mkdir "$initial_directory/$pkgs_build_base_directory/release"

	mkdir "$initial_directory/buildfarm-debs"

	base_release_directory="$initial_directory/$pkgs_build_base_directory/release/"
}
	

function build_package_universal() {
	if [[ $# -lt 6 ]]; then
		echo "bag args to build_package_universal" && exit 1
	fi
	
	local PKGNAME="$1" GITURL="$2" this_is_amd64_build="$3" this_is_i386_build="$4" this_is_arm64_build="$5" this_is_local_build="$6"
	
	# Variables:
	## PKGNAME, GITURL: Self-explanatory
	## this_is_amd64_build:
	### 1 or 0: are we connecting to the amd64 build-farm VM and building there?
	## this_is_i386_build:
	### 1 or 0: are we connecting to the i386 build-farm VM and building there?
	## this_is_arm64_build:
	### 1 or 0: are we connecting to the arm64 build-farm VM and building there?
	
	# Start by creating directories:
	##	srcdir: Source-only directory, also Git root
	##	builddir: Directory where we build the .deb package
	##	releasedir: Directory where we move the .debs after they've been built
	local srcdir="$initial_directory/$pkgs_build_base_directory/srconly/$PKGNAME"
	local sourcetarball="$initial_directory/$pkgs_build_base_directory/srconly/$PKGNAME-src.tar.gz"
	local builddir="$initial_directory/$pkgs_build_base_directory/deb/$PKGNAME"
	local releasedir="$base_release_directory/$PKGNAME"
	
	mkdir -p "$builddir"
	mkdir -p "$releasedir"
	
	# Pull updates to the source code from GITURL into our local package directory
	cd "$package_directory" || { echo "Could not cd into \"$package_directory\""; exit 1; }
	git clone "$GITURL" "$PKGNAME" -q 2>/dev/null # Clone in case we don't already have it
	cd "$PKGNAME" || { echo "Could not cd into \"$PKGNAME\""; exit 1; }
	git reset --hard
	git pull -q # Pull changes in case we do already have it (an older version)

	# Copy the updated source code into a temp directory named PKGNAME
	cd "$initial_directory/$pkgs_build_base_directory/srconly" || { echo "Could not cd into package source directory"; exit 1; }
	mkdir "$PKGNAME"
	cp -r "$package_directory/$PKGNAME/"* "./$PKGNAME/"
	
	# Tar it up so we can pass it to the build farm VMs later
	cd "$srcdir" || { echo "Could not cd into \"$srcdir\""; exit 1; }
	tar -czf "$sourcetarball" .
	
	if [[ this_is_amd64_build -eq 1 ]]; then
		# Build on the build-farm amd64 VM
		# This should only run if the VM has been turned on already
		build_other_arch "$PKGNAME" "$sourcetarball" "amd64"
		mv "$initial_directory/buildfarm-debs/"* "$releasedir/"
	fi
	
	if [[ this_is_i386_build -eq 1 ]]; then
		# Build on the build-farm i386 VM
		# This should only run if the VM has been turned on already
		build_other_arch "$PKGNAME" "$sourcetarball" "i386"
		mv "$initial_directory/buildfarm-debs/"* "$releasedir/"
	fi
	
	if [[ this_is_arm64_build -eq 1 ]]; then
		# Build on the build-farm arm64 VM
		# This should only run if the VM has been turned on already
		build_other_arch "$PKGNAME" "$sourcetarball" "arm64"
		mv "$initial_directory/buildfarm-debs/"* "$releasedir/"
	fi

	if [[ this_is_local_build -eq 1 ]]; then
		# Build locally
		cp -r "$srcdir/"* "$builddir/"
		
		# Move to the build directory, don't mess with the source directory
		cd "$builddir" || { echo "Could not cd into \"$builddir\""; exit 1; }
		
		# Build package
		debuild -us -uc
	fi
	
	# Move packages to 'release' directory
	mv "$initial_directory/$pkgs_build_base_directory/deb/"*.deb "$releasedir/" 2>/dev/null
	mv "$initial_directory/$pkgs_build_base_directory/deb/"*.tar.gz "$releasedir/" 2>/dev/null
	mv "$initial_directory/$pkgs_build_base_directory/deb/"*.dsc "$releasedir/" 2>/dev/null
	mv "$initial_directory/$pkgs_build_base_directory/deb/"*.build "$releasedir/" 2>/dev/null
	mv "$initial_directory/$pkgs_build_base_directory/deb/"*.buildinfo "$releasedir/" 2>/dev/null
	mv "$initial_directory/$pkgs_build_base_directory/deb/"*.changes "$releasedir/" 2>/dev/null
}

function clean_up() {
	# Keep only the 'release' and 'srconly' directories
	rm -rf "$initial_directory/$pkgs_build_base_directory/deb"
}

function start_build_vm() {
	# Turn on the VM
	if [[ $# != 1 ]]; then
		echo "bad args to start_build_vm" && exit 2
	fi
	
	local ARCH="$1"
	
	# Set ARCHDIR
	## ARCHDIR is the subdirectory underneath 'build-farm/' containing the QEMU VM for the arch in question
	## IE, if we want to build using the VM stored in ./build-farm/debian-stable-arm64
	## Then we would set ARCHDIR="debian-stable-arm64"
	local ARCHDIR=""

	SSHPORT=$(get_random_free_port)
	TELNETPORT=$(get_random_free_port) # FIXME: Tiny possibility of the two calls generating the same port number
	
	if [[ "$ARCH" == "amd64" ]]; then
		ARCHDIR="debian-stable-amd64"

		boot_vm_nodisplay "x86_64" "$build_farm_directory/$ARCHDIR/image.qcow" "$SSHPORT" "$TELNETPORT" &

	elif [[ "$ARCH" == "i386" ]]; then
		ARCHDIR="debian-stable-i386"
		
		boot_vm_nodisplay "i386" "$build_farm_directory/$ARCHDIR/image.qcow" "$SSHPORT" "$TELNETPORT" &
		
	elif [[ "$ARCH" == "arm64" ]]; then
		ARCHDIR="debian-stable-arm64"
		
		boot_vm_nodisplay "aarch64" "$build_farm_directory/$ARCHDIR/image.qcow" "$SSHPORT" "$TELNETPORT" &
			# Perhaps we should rename 'arm64' to 'aarch64' within Autobuild for consistency with the way Debian names things?
	fi

	echo "---"
	echo "$ARCH VM started. You can connect to it (if you want) as follows:"
	echo "  SSH Port: $SSHPORT"
	echo "  TELNET Port: $TELNETPORT"
	echo "---"
	
	sshpass -p $SSHPASSWORD ssh -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" -tt -p "$SSHPORT" $SSHUSER@127.0.0.1 >/dev/null 2>&1 << EOF

(sudo apt-get update -y >/dev/null 2>&1 && sudo apt-get upgrade -y >/dev/null 2>&1 && sudo apt-get autoremove -y >/dev/null 2>&1) && exit || exit

exit
EOF
}

function shutdown_build_vm() {
	# Connect to it on SSH and send the shutdown command
	sshpass -p $SSHPASSWORD ssh -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" -tt -p "$SSHPORT" $SSHUSER@127.0.0.1 >/dev/null 2>&1 << EOF
sudo shutdown now >/dev/null 2>&1

EOF
}

function build_other_arch() {
	if [[ $# != 3 ]]; then
		echo "bag args to build_other_arch" && exit 3
	fi
	
	local PKGNAME="$1" SOURCETARBALL="$2" ARCH="$3"
	
	# First, pass the source tarball into the VM
	## Wrapping this in "until (cmd); do sleep 5; done" ensures that we wait until the VM *can* be SSH'd into
	## The VM may take some time to come online
	until (sshpass -p $SSHPASSWORD scp -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" -P "$SSHPORT" "$SOURCETARBALL" "$SSHUSER@127.0.0.1:/tmp/$(basename "$SOURCETARBALL")" >/dev/null 2>&1); do
		sleep 5
	done
	
	# The following commands (After sshpass / ssh, until 'EOF') are passed directly to the VM
	# Here we connect and build the packages
	echo "--------"
	echo "BUILD LOG ($ARCH)"
	echo "--------"
	sshpass -p $SSHPASSWORD ssh -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" -tt -p "$SSHPORT" $SSHUSER@127.0.0.1 << EOF
mkdir -p /home/debian/build/src
mkdir -p /home/debian/build/pkg

echo "Cleaning build environment"
cd /home/debian/build/pkg
rm -rf ./*
cd /home/debian/build/src
rm -rf ./*

echo "Getting source"
mkdir "$PKGNAME"

cd "$PKGNAME"

mv /tmp/$(basename "$SOURCETARBALL") .
tar -xzf ./$(basename "$SOURCETARBALL")
rm ./$(basename "$SOURCETARBALL")

echo "Installing build dependencies"
mk-build-deps -i -s sudo -r -t "apt-get --no-install-recommends -y" && debuild -us -uc; cd .. && rm -rf "$PKGNAME/"; tar -czf /home/debian/build/pkg/packages.tar.gz ./; exit
EOF
	echo "--------"
	echo "END BUILD LOG ($ARCH)"
	echo "--------"
	
	# Now we SCP download the packages to the host machine

	# Create the tmp folder for this architecture
	mkdir "$initial_directory/$ARCH"

	sshpass -p $SSHPASSWORD scp -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" -P "$SSHPORT" -r $SSHUSER@127.0.0.1:/home/debian/build/pkg/packages.tar.gz "$initial_directory/$ARCH/packages.tar.gz" >/dev/null 2>&1
	
	cd "$initial_directory/$ARCH" || { echo "Could not cd into \"$initial_directory/$ARCH\""; exit 1; }
	tar -xzf packages.tar.gz
	rm -f packages.tar.gz
	mv "$initial_directory/$ARCH/"* "$initial_directory/buildfarm-debs/"
	rm -f "$initial_directory/$ARCH/"*
}

function build_all_pkgs_in_pkgarrays() {

	local building_some_on_amd64=0 building_some_on_i386=0 building_some_on_arm64=0

	if [[ ${#amd64_builds[@]} -gt 0 ]]; then
		building_some_on_amd64=1
	fi

	if [[ ${#i386_builds[@]} -gt 0 ]]; then
		building_some_on_i386=1
	fi
	
	if [[ ${#arm64_builds[@]} -gt 0 ]]; then
		building_some_on_arm64=1
	fi

	if [[ building_some_on_amd64 -eq 1 ]]; then
		# Start the VM, build all the packages, and then shut it down
		start_build_vm "amd64"
		for pkgname in "${packages_to_build[@]}"; do
			build_package_universal "$pkgname" "${packages[$pkgname]}" 1 0 0 0
		done
		shutdown_build_vm
	fi

	if [[ building_some_on_i386 -eq 1 ]]; then
		# Start the VM, build all the packages, and then shut it down
		start_build_vm "i386"
		for pkgname in "${i386_builds[@]}"; do
			build_package_universal "$pkgname" "${packages[$pkgname]}" 0 1 0 0
		done
		shutdown_build_vm
	fi
	
	if [[ building_some_on_arm64 -eq 1 ]]; then
		# Start the VM, build all the packages, and then shut it down
		start_build_vm "arm64"
		for pkgname in "${arm64_builds[@]}"; do
			build_package_universal "$pkgname" "${packages[$pkgname]}" 0 0 1 0
		done
		shutdown_build_vm
	fi

	if [[ building_some_on_amd64 -eq 0 && building_some_on_i386 -eq 0 && building_some_on_i386 -eq 0 ]]; then
		# Building packages locally
		for pkgname in "${packages_to_build[@]}"; do
			build_package_universal "$pkgname" "${packages[$pkgname]}" 0 0 0 1
		done
	fi
}

function push_github_release_page() {
	if [[ $# != 1 ]]; then
		echo "bag args to push_github_release_page" && exit 4
	fi
	
	local PKGNAME="$1" CHANGELOG="" VERSION=""
	
	# Get package info: Latest changelog entry + latest version number
	
	## Get changelog from package source using dpkg-parsechangelog (dpkg-dev package)
	### Pipe into sed to:
	### (1) Escape backslashes (\ to \\)
	### (2) Replace newline chars with '\n' (literal)
	### (3) Escape quotes (" to \\\") [See 'curl' statement below to see why a triple-backslash is needed]
	### (4) Strip down to JUST the latest changelog message (Not any other metadata, just the message the author wrote) (Everything after the first '* ')
	CHANGELOG=$(dpkg-parsechangelog -l "$initial_directory/$pkgs_build_base_directory/srconly/$PKGNAME/debian/changelog" --show-field changes | sed -z 's/\\/\\\\/g' | sed -z 's/\n  /\\n/g' | sed -z 's/\n/\\n/g' | sed -z 's/\"/\\\\\\\"/g' | sed -n 's/.*\* //p')

	## Get version number from package source using dpkg-parsechangelog
	### Pipe into sed to remove the ending newline char
	VERSION=$(dpkg-parsechangelog -l "$initial_directory/$pkgs_build_base_directory/srconly/$PKGNAME/debian/changelog" --show-field version | sed -z 's/\n//g')
	
	# Create GitHub Release
	
	## Send POST request to GitHub API to create a release page
	curl -L \
			-X POST \
			-H "Accept: application/vnd.github+json" \
			-H "Authorization: Bearer $ACCESS_TOKEN" \
			-H "X-GitHub-Api-Version: 2022-11-28" \
			"https://api.github.com/repos/$OWNER/$PKGNAME/releases" \
			-d "{\"tag_name\": \"v$VERSION\",
				\"target_commitish\": \"main\",
				\"name\": \"v$VERSION\",
				\"body\": \"$CHANGELOG\",
				\"draft\": false,
				\"prerelease\": false,
				\"generate_release_notes\": false}" > "$base_release_directory/$PKGNAME/release-info"
	
	## Get GitHub Release ID
	RELEASEID=$(jq -r '.id' "$base_release_directory/$PKGNAME/release-info")

	## Upload the attachments via POST request to the GitHub API
	for file in "$base_release_directory/$PKGNAME/"*.deb; do
		curl -L \
			-X POST \
			-H "Accept: application/vnd.github+json" \
			-H "Authorization: Bearer $ACCESS_TOKEN" \
			-H "X-Github-Api-Version: 2022-11-28" \
			-H "Content-Type: application/octet-stream" \
			"https://uploads.github.com/repos/$OWNER/$PKGNAME/releases/$RELEASEID/assets?name=$(basename "$file")" \
			--data-binary "@$file"
	done
}

function prepare_ghpages_debian_repo() {
	# Clone the git repo into a local directory
	cd "$local_storage_directory" || { echo "Could not cd into \"$local_storage_directory\""; exit 1; }
	git clone "$git_debianrepo" "repo" -q 2>/dev/null
	cd "repo" || { echo "Could not cd into \"$local_storage_directory/repo\""; exit 1; }
	git reset --hard
	git pull -q
}

function close_ghpages_debian_repo() {
	cd "$local_storage_directory/repo" || { echo "Could not cd into \"$local_storage_directory/repo\""; exit 1; }
	
	# Push the changes we've made before calling this function
	git push origin -q
}

function push_to_ghpages_debian_repo() {
	# Pushes a package to a Debian Repository hosted on GitHub Pages
	# The repo must be managed via 'reprepro'
	# This should be called AFTER prepare_ghpages_debian_repo() and BEFORE close_ghpages_debian_repo()
	
	if [[ $# != 1 ]]; then
		echo "bag args to push_to_ghpages_debian_repo" && exit 5
	fi
	
	local PKGNAME="$1"
	
	repo_base_directory=$(dirname "$(find "$local_storage_directory/repo" -name "pool")")
	cd "$repo_base_directory" || { echo "Could not cd into \"$repo_base_directory\""; exit 1; }

	debian_distribution=$(grep Codename: <"$repo_base_directory/conf/distributions" | awk '{print $2}' | head -n 1)
	
	# Add .changes files to the repo
	for changes_file in "$base_release_directory/$PKGNAME/"*.changes; do
		reprepro -P optional include "$debian_distribution" "$changes_file"
	done
	
	# Update indexes and commit changes
	cd "$local_storage_directory/repo" || { echo "Could not cd into \"$local_storage_directory/repo\""; exit 1; }
	git add --all
	git commit -m "Updated $PKGNAME"
}

function maybe_publish_to_deb_repo() {
	if [[ ${#packages_to_publish_to_repo[@]} -gt 0 ]]; then
		echo "Publishing to repo..."
		
		prepare_ghpages_debian_repo
		
		for pkg in "${packages_to_publish_to_repo[@]}"; do
			push_to_ghpages_debian_repo "$pkg"
		done
		
		close_ghpages_debian_repo
	fi
}

function maybe_make_github_release_page() {
	if [[ ${#release_pages_to_make[@]} -gt 0 ]]; then
		echo "Making release pages..."
		
		for pkg in "${release_pages_to_make[@]}"; do
			push_github_release_page "$pkg"
		done
	fi
}

function save_debs() {
		cp -r "$initial_directory/$pkgs_build_base_directory/release/"* "$output_directory/"
}

function delete_temp_files() {
	rm -rf "$tempdirectory/autobuild"*
}

function display_help() {
	echo "autobuild"
	echo "Copyright (C) 2024 rail5"
	echo ""
	echo "This program comes with ABSOLUTELY NO WARRANTY."
	echo "This is free software (GNU Affero GPL V3), and you are welcome to redistribute it under certain conditions."
	echo ""
	echo "You should edit CONFIG and run setup before using this program"
	echo ""
	echo "Options:"
	echo ""
	echo "  -p"
	echo "  --package"
	echo "    Add a package to the build list"
	echo ""
	echo "  -0"
	echo "  --local"
	echo "    Build packages locally (do not use the Build Farm)"
	echo ""
	echo "  -1"
	echo "  --amd64"
	echo "    Build packages on the amd64 Build Farm VM"
	echo ""
	echo "  -2"
	echo "  --i386"
	echo "    Build packages on the i386 Build Farm VM"
	echo ""
	echo "  -3"
	echo "  --arm64"
	echo "    Build packages on the arm64 Build Farm VM"
	echo ""
	echo "  -o"
	echo "  --output"
	echo "    Specify directory to save built package files (Default: current directory)"
	echo ""
	echo "  -d"
	echo "  --debian-repo"
	echo "    Distribute built packages to a Git-based Debian Repository managed with reprepro"
	echo ""
	echo "  -g"
	echo "  --github-page"
	echo "    Create a Release page on the built packages' Github repositories"
	echo ""
	echo "  -b"
	echo "  --bell"
	echo "    Ring a bell when finished"
	echo ""
	echo "  -s"
	echo "  --setup"
	echo "    Run the setup script (after editing your CONFIG file)"
	echo ""
	echo "  -c"
	echo "  --config"
	echo "    Open the CONFIG file for editing"
	echo ""
	echo "  -l"
	echo "  --list"
	echo "    List packages available to build (list can be modified via the CONFIG file)"
	echo ""
	echo "Example:"
	echo "  autobuild -12dg -p liesel -p bookthief -p polonius"
	echo "  autobuild --i386 --arm64 --debian-repo --github-page --package liesel --package bookthief --package polonius"
	echo "  autobuild -p liesel -o ~/Desktop/"
}


# And now the program:


# Check if the user has provided us arguments for non-interactive mode

TEMP=$(getopt -o 0123bcdghlo:p:s --long local,amd64,i386,arm64,bell,config,debian-repo,github-page,help,list,output:,package:,setup \
              -n 'autobuild' -- "$@")

if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi

eval set -- "$TEMP"

package_provided=false
target_architecture_provided=false
building_locally=false
building_on_amd64=false
building_on_i386=false
building_on_arm64=false
distribute_to_debian_repo=false
distribute_to_github_page=false

ring_bell=false

while true; do
	case "$1" in
		-0 | --local )
			building_locally=true
			target_architecture_provided=true
			shift ;;
		-1 | --amd64 )
			if [[ $amd64_vm_is_configured == "true" ]]; then
				building_on_amd64=true
				target_architecture_provided=true
			else
				echo "The amd64 VM is not configured."
			fi
			shift ;;
		-2 | --i386 )
			if [[ $i386_vm_is_configured == "true" ]]; then
				building_on_i386=true
				target_architecture_provided=true
			else
				echo "The i386 VM is not configured."
			fi
			shift ;;
		-3 | --arm64 )
			if [[ $arm64_vm_is_configured == "true" ]]; then
				building_on_arm64=true
				target_architecture_provided=true
			else
				echo "The arm64 VM is not configured"
			fi
			shift ;;
		-b | --bell )
			ring_bell=true; shift ;;
		-c | --config )
			xdg-open "$CONFIG_FILE"; exit 0 ;;
		-d | --debian-repo )
			distribute_to_debian_repo=true; shift ;;
		-g | --github-page )
			distribute_to_github_page=true; shift ;;
		-h | --help )
			display_help; exit 0 ;;
		-l | --list )
			for pkgname in "${!packages[@]}"; do
				echo "$pkgname"
			done
			exit 0 ;;
		-o | --output )
			output_directory=$(realpath "$2"); shift 2 ;;
		-p | --package )
			if [ ${packages[$2]+1} ]; then
				packages_to_build+=("$2");
				package_provided=true
				echo "Building $2"
			else
				echo "ERROR: Package '$2' not in CONFIG!";
			fi;
			shift 2 ;;
		-s | --setup )
			autobuild-setup;
			exit 0 ;;
		-- ) shift; break ;;
		* ) break ;;
	esac
done

setup_build_environment

if [ $package_provided == false ]; then
	echo "Error: No package names provided."
	echo "See 'autobuild -h' or 'man autobuild' for more information."
	exit 1
fi

if [ $target_architecture_provided == false ]; then
	echo "Warning: No target architecture provided."
	building_locally=true
fi

if [ $building_locally == true ]; then
	echo "Building packages locally"
	building_on_amd64=false
	building_on_i386=false
	building_on_arm64=false
fi

if [ $building_on_amd64 == true ]; then
	echo "Building packages for amd64"
	for pkgname in "${packages_to_build[@]}"; do
		amd64_builds+=("$pkgname")
	done
fi

if [ $building_on_i386 == true ]; then
	echo "Building packages for i386"
	for pkgname in "${packages_to_build[@]}"; do
		i386_builds+=("$pkgname")
	done
fi

if [ $building_on_arm64 == true ]; then
	echo "Building packages for arm64"
	for pkgname in "${packages_to_build[@]}"; do
		arm64_builds+=("$pkgname")
	done
fi

# Check if and how we're distributing the built packages
if [ $distribute_to_debian_repo == true ]; then
	echo "Publishing packages to Debian repo"
	for pkgname in "${packages_to_build[@]}"; do
		packages_to_publish_to_repo+=("$pkgname")
	done
fi

if [ $distribute_to_github_page == true ]; then
	echo "Publishing packages to Github release pages"
	for pkgname in "${packages_to_build[@]}"; do
		release_pages_to_make+=("$pkgname")
	done
fi

build_all_pkgs_in_pkgarrays
clean_up

save_debs

maybe_publish_to_deb_repo
maybe_make_github_release_page

delete_temp_files

if [ $ring_bell == true ]; then
	paplay /usr/share/autobuild/bell.ogg
fi

echo "" # End with newline
